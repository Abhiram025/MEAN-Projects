authController.js
async register(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        console.error("The data is incorrect")
        return res.status(400).json({ errors: errors.array() });
      }
      const user = await AuthService.register(req.body);
      const token = jwt.sign(
        { 
     
          username: user.username, 
          role: user.role 
        },
        config.JWT_SECRET,
        { expiresIn: '30d' }
      );
      const userResponse = {
      
        username: user.username,
        firstname: user.firstname,
        lastname: user.lastname,
        address: user.address,
        email: user.email,
        role: user.role,
      };
      res.status(201).json({ 
        user: userResponse,
        token 
      });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  } 

userModel.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  firstname: {
    type: String,
    required: true,
    // Only if names must be unique
  },
  lastname: String,
  phone: String,
  address: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (v) {
        // Regex for basic email validation
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
      },
      message: props => ${props.value} is not a valid email address!
    }
  },
  password: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin'], default: 'user' },

  loyaltyPoints: { type: Number, default: 0 },
  eligibleForDiscountedRides: { type: Number, default: 0 },
  resetPasswordToken: String,
  resetPasswordExpires: Date
}, { timestamps: true });

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

authService.js
const UserDAL = require('../dal/userDal');
const jwt = require('jsonwebtoken');
const config = require('../config');

class AuthService {
  async register(userData) {
    const existingUser = await UserDAL.findByUsername(userData.username) || 
                        await UserDAL.findByEmail(userData.email);
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    return await UserDAL.create(userData);
  }

  async login(username, password) {
    const user = await UserDAL.findByUsername(username);
    if (!user) {
      throw new Error('User not found');
    }
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      throw new Error('Invalid credentials');
    }
    const token = jwt.sign(
      {  role: user.role }, 
      config.JWT_SECRET, 
      { expiresIn: '1d' }
    );
    return { user, token };
  }

  async createAdmin(adminData) {
    adminData.role = 'admin';
    return await this.register(adminData);
  }
}

module.exports = new AuthService();

userDal.js
const BaseDAL = require('./baseDal');
const User = require('../models/userModel');

class UserDAL extends BaseDAL {
  constructor() {
    super(User);
  }

  async findByUsername(username) {
    return await this.findOne({ username });
  }

  async findByEmail(email) {
    return await this.findOne({ email });
  }
}

module.exports = new UserDAL();
baseDal.js
class BaseDAL {
  constructor(model) {
    this.model = model;
  }

  async create(data) {
    return await this.model.create(data);
  }

  async findById(id) {
    return await this.model.findById(id);
  }

  async findOne(conditions) {
    return await this.model.findOne(conditions);
  }

  async find(conditions = {}) {
    return await this.model.find(conditions);
  }

  async updateById(id, data) {
    return await this.model.findByIdAndUpdate(id, data, { new: true });
  }

  async deleteById(id) {
    return await this.model.findByIdAndDelete(id);
  }
}

module.exports = BaseDAL;

authRoutes.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const validate  = require('../middleware/validation');
const { check } = require('express-validator');

router.post('/register', 
  validate([
    check('username').not().isEmpty().withMessage('Username is required'),
    check('firstName').not().isEmpty(),
    check('lastName').not().isEmpty(),
    check('address').not().isEmpty(),
    check('email').isEmail().withMessage('Valid email is required'),
    check('password').isLength({ min: 11 }).withMessage('Password must be at least 11 characters')    
  ]),
  authController.register
);

router.post('/login', 
  validate([
    check('username').not().isEmpty().withMessage('Username is required'),
    check('password').not().isEmpty().withMessage('Password is required')
  ]),
  authController.login
);

module.exports = router;
{ 
    "errors": [
        {
            "type": "field",
            "msg": "Invalid value",
            "path": "firstName",
            "location": "body"
        },
        {
            "type": "field",
            "msg": "Invalid value",
            "path": "lastName",
            "location": "body"
        }
    ]
} why am i getting this error in postman for this data
{
    "username":"Ritesh1311",
    "firstname":"Ritesh",
    "lastname":"Kavali",
    "address":"kadapa, AP",
    "email":"ritesh1105@gmail.com",
    "password":"09876543211"
} send through POST request in /api/register

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MjJjZTEyOGM1ZjE2OTQ4YWIzODRlZSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTc0NzExMjE1NywiZXhwIjoxNzQ3MTk4NTU3fQ.SGj6C4CsoaQFPtqndBuKKePudKymEM0hU4jE06QkNqM-token
{
    "message": "E11000 duplicate key error collection: carzy_rentals.users index: profile.firstName_1 dup key: { profile.firstName: null }"
}
