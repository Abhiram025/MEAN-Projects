rentalController.js
const RentalService = require('../services/rentalService');

class RentalController {
  async bookCar(req, res) {
    try {
      const { carId, rentalStartDate, rentalEndDate } = req.body;
      const rental = await RentalService.bookCar(
        req.user.id, 
        carId, 
        new Date(rentalStartDate), 
        new Date(rentalEndDate)
      );
      res.status(201).json(rental);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async pickupCar(req, res) {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Forbidden' });
      }
      const rental = await RentalService.pickupCar(
        req.params.id, 
        req.body.pickupOdometerReading
      );
      res.json(rental);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async returnCar(req, res) {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Forbidden' });
      }
      const rental = await RentalService.returnCar(
        req.params.id, 
        req.body.returnOdometerReading
      );
      res.json(rental);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async cancelBooking(req, res) {
    try {
      await RentalService.cancelBooking(
        req.params.id, 
        req.user.id, 
        req.user.role === 'admin'
      );
      res.json({ message: 'Booking cancelled successfully' });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async getUserRentals(req, res) {
    try {
      const rentals = await RentalService.getUserRentals(req.user.id, req.query.type);
      res.json(rentals);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async getAllRentals(req, res) {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Forbidden' });
      }
      const rentals = await RentalService.getAllRentals();
      res.json(rentals);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async getUserRentalHistory(req, res) {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: 'Forbidden' });
      }
      const rentals = await RentalService.getUserRentals(req.params.userId);
      res.json(rentals);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }
}

module.exports = new RentalController();

rentalDal.js
const BaseDAL = require('./baseDal');
const Rental = require('../models/rentalModel');

class RentalDAL extends BaseDAL {
  constructor() {
    super(Rental);
  }

  async findUserRentals(userId, status) {
    const query = { user: userId };
    if (status) {
      if (status === 'previous') {
        query.status = 'completed';
      } else if (status === 'future') {
        query.status = { $in: ['booked', 'rented'] };
      }
    }
    return await this.find(query).populate('car');
  }

  async findAllRentals() {
    return await this.find().populate('user car');
  }
}

module.exports = new RentalDAL();

carModel.js
const mongoose = require('mongoose');

const rentalSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  car: { type: mongoose.Schema.Types.ObjectId, ref: 'Car', required: true },
  rentalStartDate: { type: Date, required: true },
  rentalEndDate: { type: Date, required: true },
  actualPickupDate: Date,
  actualReturnDate: Date,
  pickupOdometer: Number,
  returnOdometer: Number,
  totalKmDriven: Number,
  baseCostPerKm: Number,
  baseCostPerDay: Number,
  taxRateApplied: Number,
  taxAmount: Number,
  frequentRenterDiscountAmount: Number,
  loyaltyDiscountAmount: Number,
  totalCost: Number,
  status: { 
    type: String, 
    enum: ['booked', 'rented', 'completed', 'cancelled'], 
    default: 'booked' 
  },
  loyaltyPointsEarned: { type: Number, default: 0 }
}, { timestamps: true });

module.exports = mongoose.model('Rental', rentalSchema);

carRouter.js
const express = require('express');
const router = express.Router();
const rentalController = require('../controllers/rentalController');
const { authenticate } = require('../middleware/auth');

router.use(authenticate);

router.post('/', rentalController.bookCar);
router.get('/', rentalController.getUserRentals);
router.get('/all', rentalController.getAllRentals);
router.get('/user/:userId', rentalController.getUserRentalHistory);
router.put('/:id/pickup', rentalController.pickupCar);
router.put('/:id/return', rentalController.returnCar);
router.delete('/:id', rentalController.cancelBooking);

module.exports = router;

carService.js
const RentalDAL = require('../dal/rentalDal');
const CarDAL = require('../dal/carDal');
const UserDAL = require('../dal/userDal');
const TaxService = require('./taxService');

const KM_FOR_LOYALTY_POINT = 50;
const POINTS_FOR_DISCOUNT_RIDES = 25;
const DISCOUNTED_RIDES_COUNT = 2;
const FREQUENT_RENTER_KM_THRESHOLD = 1000;
const FREQUENT_RENTER_DISCOUNT_RATE = 0.10;
const LOYALTY_RIDE_DISCOUNT_FIXED_AMOUNT = 20;

class RentalService {
  async bookCar(userId, carId, rentalStartDate, rentalEndDate) {
    const [car, user] = await Promise.all([
      CarDAL.findById(carId),
      UserDAL.findById(userId)
    ]);
    
    if (!car || car.availabilityStatus !== 'available') {
      throw new Error('Car not available for booking');
    }
    if (!user) throw new Error('User not found');

    const taxRule = await TaxService.getTaxByCarType(car.type);
    if (!taxRule) throw new Error('Tax rule not found for car type');

    return await RentalDAL.create({
      user: userId,
      car: carId,
      rentalStartDate,
      rentalEndDate,
      baseCostPerKm: car.pricePerKm,
      baseCostPerDay: car.pricePerDay,
      taxRateApplied: taxRule.taxPercentage / 100,
      status: 'booked'
    });
  }

  async pickupCar(rentalId, pickupOdometerReading) {
    const rental = await RentalDAL.findById(rentalId);
    if (!rental || rental.status !== 'booked') {
      throw new Error('Invalid rental for pickup');
    }

    const car = await CarDAL.findById(rental.car);
    if (!car || pickupOdometerReading < car.currentOdometer) {
      throw new Error('Invalid odometer reading');
    }

    await CarDAL.updateById(rental.car, {
      availabilityStatus: 'rented',
      currentOdometer: pickupOdometerReading
    });

    return await RentalDAL.updateById(rentalId, {
      actualPickupDate: new Date(),
      pickupOdometer: pickupOdometerReading,
      status: 'rented'
    });
  }

  async returnCar(rentalId, returnOdometerReading) {
    const rental = await RentalDAL.findById(rentalId).populate('user car');
    if (!rental || rental.status !== 'rented') {
      throw new Error('Invalid rental for return');
    }
    if (!rental.pickupOdometer || returnOdometerReading < rental.pickupOdometer) {
      throw new Error('Invalid odometer reading');
    }

    const totalKmDriven = returnOdometerReading - rental.pickupOdometer;
    const durationDays = Math.ceil((new Date() - rental.actualPickupDate) / (1000 * 60 * 60 * 24));
    
    let calculatedCost = durationDays * rental.baseCostPerDay + totalKmDriven * rental.baseCostPerKm;
    const taxAmount = calculatedCost * rental.taxRateApplied;
    let finalCost = calculatedCost + taxAmount;

    // Apply frequent renter discount
    const pastRentals = await RentalDAL.find({ user: rental.user._id, status: 'completed' });
    const totalUserKmRented = pastRentals.reduce((sum, r) => sum + (r.totalKmDriven || 0), 0);

    if ((totalUserKmRented + totalKmDriven) > FREQUENT_RENTER_KM_THRESHOLD) {
      finalCost -= finalCost * FREQUENT_RENTER_DISCOUNT_RATE;
    }

    // Apply loyalty discount if available
    if (rental.user.eligibleForDiscountedRides > 0) {
      finalCost -= LOYALTY_RIDE_DISCOUNT_FIXED_AMOUNT;
      rental.user.eligibleForDiscountedRides -= 1;
    }
    finalCost = Math.max(0, finalCost);

    // Update loyalty points
    const loyaltyPointsEarned = Math.floor(totalKmDriven / KM_FOR_LOYALTY_POINT);
    rental.user.loyaltyPoints += loyaltyPointsEarned;

    if (rental.user.loyaltyPoints >= POINTS_FOR_DISCOUNT_RIDES) {
      const setsOfPoints = Math.floor(rental.user.loyaltyPoints / POINTS_FOR_DISCOUNT_RIDES);
      rental.user.eligibleForDiscountedRides += setsOfPoints * DISCOUNTED_RIDES_COUNT;
      rental.user.loyaltyPoints %= POINTS_FOR_DISCOUNT_RIDES;
    }

    await UserDAL.updateById(rental.user._id, {
      loyaltyPoints: rental.user.loyaltyPoints,
      eligibleForDiscountedRides: rental.user.eligibleForDiscountedRides
    });

    await CarDAL.updateById(rental.car._id, {
      availabilityStatus: 'available',
      currentOdometer: returnOdometerReading
    });

    return await RentalDAL.updateById(rentalId, {
      actualReturnDate: new Date(),
      returnOdometer: returnOdometerReading,
      totalKmDriven,
      taxAmount,
      totalCost: finalCost,
      status: 'completed',
      loyaltyPointsEarned
    });
  }

  async cancelBooking(rentalId, userId, isAdmin = false) {
    const rental = await RentalDAL.findById(rentalId).populate('user');
    if (!rental) throw new Error('Rental not found');
    if (!isAdmin && rental.user._id.toString() !== userId.toString()) {
      throw new Error('Not authorized to cancel this booking');
    }
    if (rental.status !== 'booked') throw new Error('Cannot cancel booking');

    return await RentalDAL.updateById(rentalId, { status: 'cancelled' });
  }

  async getUserRentals(userId, type = 'all') {
    return await RentalDAL.findUserRentals(userId, type);
  }

  async getAllRentals() {
    return await RentalDAL.findAllRentals();
  }
}

module.exports = new RentalService();
these are the codes for my rental operations im getting this error in postman
{
    "message": "User not found"
} i gave the bearer token in authorization tab

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MjJjZTEyOGM1ZjE2OTQ4YWIzODRlZSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTc0NzExMjE1NywiZXhwIjoxNzQ3MTk4NTU3fQ.SGj6C4CsoaQFPtqndBuKKePudKymEM0hU4jE06QkNqM-admin1 token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkplZXZhNjg3Iiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNzQ3MTI0MzUzLCJleHAiOjE3NDk3MTYzNTN9.8iEIw6jsLX9DiqvkOzy8lGxSALIBSTeCytVoPiDL9Yg-admin2 token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoidXNlciIsImlhdCI6MTc0NzEyOTYyOSwiZXhwIjoxNzQ3MjE2MDI5fQ.XDazMVx1uTsQE7qDwoG-U0BxX-dqKhtk-YgwNcprX-g-user token


