userRoutes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { authenticate } = require('../middleware/auth');

router.post('/forgot-password', userController.requestPasswordReset);
router.patch('/reset-password/:token', userController.resetPasswordToken)

router.use(authenticate);

router.get('/profile', userController.getProfile);
router.put('/profile', userController.updateProfile);
router.put('/change-password', userController.changePassword);
router.put('/reset-password', userController.resetPassword);

module.exports = router;

userController.js
const UserService = require('../services/userService');

class UserController {
  async getProfile(req, res) {
    try {
      const user = await UserService.getUserById(req.user.id);
      res.json(user);
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  }

  async updateProfile(req, res) {
    try {
      const user = await UserService.updateProfile(req.user.id, req.body);
      res.json(user);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async changePassword(req, res) {
    try {
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: 'Both current and new password are required' });
      }
      await UserService.changePassword(req.user.id, currentPassword, newPassword);
      res.json({ message: 'Password changed successfully' });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async requestPasswordReset(req, res) {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: 'Email is required' });
      }
      const resetToken=await UserService.requestPasswordReset(email);

      ers.json({
        status:'success',
        message:'Token sent to email',
        token: resetToken//remove this in production
      })
      
    } catch (error) {
      res.status(500).json({status:'error', message: error.message });
    }
  }

  async resetPasswordToken(req, res) {
    try {
      const {token}=req.params;
      const {newPassword, confirmPassword}=req.body;

      await UserService.resetPasswordWithToken(token, newPassword, confirmPassword);
      res.json({status:'success', message:'Password updated successfully'})
    }
    catch(err) {
      const statusCode=err.message.includes('Token')?400:500;
      res.status(statusCode).json({status:'error',message:err.message})
    }
  }

 async resetPasswordToken(req, res) {
    try {
      const {token}=req.params;
      const {newPassword, confirmPassword}=req.body;

      await UserService.resetPasswordWithToken(token, newPassword, confirmPassword);
      res.json({status:'success', message:'Password updated successfully'})
    }
    catch(err) {
      console.log("you have got an error 2")
      const statusCode=err.message.includes('token')?400:500;
      res.status(statusCode).json({status:'error',message:err.message})
    }
  }
}

module.exports = new UserController();

userService.js
const UserDAL = require('../dal/userDal');
const { validate } = require('../models/userModel');
const crypto=require('crypto')

class UserService {
  async updateProfile(userId, profileData) {
    return await UserDAL.updateById(userId, profileData);
  }

  async changePassword(userId, currentPassword, newPassword) {
    const user = await UserDAL.findById(userId);
    const isMatch = await user.comparePassword(currentPassword);
    if (!isMatch) {
      throw new Error('Current password is incorrect');
    }

    if (newPassword.length < 8) {
      throw new Error('Password must be at least 8 characters');
    }

    // Hash and save new password
    user.password = newPassword;
    await user.save(); // This triggers the pre-save hook

    return user;
  }

  async requestPasswordReset(email) {
    const user = await UserDAL.findByEmail(email);
    if (!user) return; // Don't reveal if email exists

    const resetToken=user.createPasswordResetToken();
    await user.save({validateBeforeSave: false});

    return resetToken
  }

async resetPasswordWithToken(token, newPassword, confirmPassword) {
    if (newPassword !== confirmPassword) throw new Error("Passwords don't match");
    if (newPassword.length < 8) throw new Error('Password must be atleast 8 characters');

    const hashedToken=crypto.createHash('sha256').update(token).digest('hex');
    const user = await UserDAL.findByResetToken(hashedToken);
    console.log("level 2 is here")
    if (!user) throw new Error("Token is invalid or has expired")

    const samePassword = await user.comparePassword(newPassword);
    if (samePassword) throw new Error("Cannot use previous password");

    user.password = newPassword;
    user.resetToken=undefined;
    user.resetTokenExpiry=undefined;

    await user.save();
    return user;
  }

  async getUserById(userId) {
    return await UserDAL.findById(userId);
  }
}

module.exports = new UserService();

userModel.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  phone: {
    type: String,
    required: [true, 'phone number is required'],
    validate: {
      validator: function (v) {
        return /^\d{10}$/.test(v)
      }
    }
  },
  email: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (v) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
      },
      message: props => `${props.value} is not a valid email address!`
    }
  },
  password: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  loyaltyPoints: { type: Number, default: 0 },
  eligibleForDiscountedRides: { type: Number, default: 0 },
  resetToken: String,
  resetTokenExpiry: Date
}, { timestamps: true });

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (err) {
    next(err)
  }


});


userSchema.methods.createPasswordResetToken = () => {
  const resetToken = crypto.randomBytes(32).toString('hex');
  this.resetToken = crypto.createHash('sha256').update(resetToken).digest('hex');

  this.resetTokenExpiry = Date.now()+ 10 * 60 * 1000;
  return resetToken;
}



userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};


module.exports = mongoose.model('User', userSchema);
