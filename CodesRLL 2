userRoutes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { authenticate } = require('../middleware/auth');

router.use(authenticate);

router.get('/profile', userController.getProfile);
router.put('/profile', userController.updateProfile);
router.put('/change-password', userController.changePassword);

router.post('/request-password-reset', userController.requestPasswordReset);
router.put('/reset-password', userController.resetPassword);

module.exports = router;

userController.js
const UserService = require('../services/userService');

class UserController {
  async getProfile(req, res) {
    try {
      const user = await UserService.getUserById(req.user.id);
      res.json(user);
    } catch (error) {
      res.status(404).json({ message: error.message });
    }
  }

  async updateProfile(req, res) {
    try {
      const user = await UserService.updateProfile(req.user.id, req.body);
      res.json(user);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async changePassword(req, res) {
    try {
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: 'Both current and new password are required' });
      }
      await UserService.changePassword(req.user.id, currentPassword, newPassword);
      res.json({ message: 'Password changed successfully' });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }

  async requestPasswordReset(req, res) {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: 'Email is required' });
      }

      // Generate and store a reset token (expires in 1 hour)
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetTokenExpiry = Date.now() + 3600000; // 1 hour

      await UserService.createPasswordResetToken(email, resetToken, resetTokenExpiry);

      // In reality, you would send this link via email
      const resetLink = `${req.protocol}://${req.get('host')}/reset-password?token=${resetToken}`;

      res.json({
        message: 'If this email exists, a reset link has been sent',
        resetLink // Only for development/testing!
      });
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  }

  async resetPassword(req, res) {
    try {
      const { email, newPassword, confirmPassword } = req.body;
      if (!email || !newPassword || !confirmPassword) {
        return res.status(400).json({ message: 'All fields are required' });
      }
      await UserService.resetPasswordWithToken(req.user?.id, email, newPassword, confirmPassword);
      res.status(200).json({ message: 'Password Reset is Successful' });
    } catch (err) {
      console.log("Password reset error: ", err.message);
      const statusCode = err.message.includes('not found') ? 404 : 400;
      res.status(statusCode).json({
        message: err.message || 'Password reset failed'
      });
    }
  }
}

module.exports = new UserController();

userModel.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  phone: {
    type: String,
    required: [true, 'phone number is required'],
    validate: {
      validator: function (v) {
        return /^\d{10}$/.test(v)
      }
    }
  },
  email: {
    type: String,
    required: true,
    unique: true,
    validate: {
      validator: function (v) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
      },
      message: props => `${props.value} is not a valid email address!`
    }
  },
  password: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  loyaltyPoints: { type: Number, default: 0 },
  eligibleForDiscountedRides: { type: Number, default: 0 },
  resetToken: String,
  resetTokenExpiry: Date
}, { timestamps: true });

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (err) {
    next(err)
  }

});


userSchema.methods.createPasswordResetToken=()=>{
  const resetToken=crypto.randomBytes(32).toString('hex');
  this.resetToken=crypto.createHash('sha256').update(resetToken).digest('hex');

  this.resetTokenExpiry=Date.now()+10*60*1000;
  return resetToken;
}

userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.checkPassword = async function (candidateNewPassword) {
  return await bcrypt.compare(candidateNewPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

userService.js
const UserDAL = require('../dal/userDal');

class UserService {
  async updateProfile(userId, profileData) {
    return await UserDAL.updateById(userId, profileData);
  }

  async changePassword(userId, currentPassword, newPassword) {
    const user = await UserDAL.findById(userId);
    const isMatch = await user.comparePassword(currentPassword);
    if (!isMatch) {
      throw new Error('Current password is incorrect');
    }

    if (newPassword.length < 8) {
      throw new Error('Password must be at least 8 characters');
    }

    // Hash and save new password
    user.password = newPassword;
    await user.save(); // This triggers the pre-save hook

    return user;
  }

  async createPasswordResetToken(email, token, expiry) {
    const user = await UserDAL.findByEmail(email);
    if (!user) return; // Don't reveal if email exists

    user.resetToken = token;
    user.resetTokenExpiry = expiry;
    await user.save();
  }

  async resetPasswordWithToken(userId, email, newPassword, confirmPassword) {
    const user = userId ? UserDAL.findById(userId) : UserDAL.findByEmail(email);
    if (!user) throw new Error("User not found")

    if (newPassword !== confirmPassword) throw new Error("Passwords don't match")
    if (newPassword.length < 8) throw new Error('Password must be atleast 8 characters')

    const samePassword = await user.checkPassword(newPassword);//problem
    if (samePassword) throw new Error("Cannot use previous password")

    user.password = newPassword;
    await user.save();
    return user;
  }

  async getUserById(userId) {
    return await UserDAL.findById(userId);
  }
}

module.exports = new UserService();

middleware/auth.js
const jwt = require('jsonwebtoken');
const config = require('../config');

module.exports = {
  authenticate: (req, res, next) => {
    const authHeader = req.headers['authorization'] || req.headers['Authorization'];
    if (!authHeader) {
      return res.status(401).json({ message: 'No token, authorization denied' });
    }

    const token=authHeader.replace(/^Bearer\s+/i, '')
    console.log("Extracted token: ", token)//debug

    if(!token) {
      return res.status(401).json({message: 'No token, authorization denied'})
    }
    try {
      const decoded = jwt.verify(token, config.JWT_SECRET);
      console.log('Decoded Token Payload: ', decoded)//debug
      req.user = decoded;
      next();
    } catch (error) {
      console.error('JWT Verification Error: ', error)//debug
      res.status(401).json({ message: 'Token is not valid' });
    }
  },

  authorizeAdmin: (req, res, next) => {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Forbidden' });
    }
    next();
  }
};
